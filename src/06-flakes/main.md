---
title: Flakes
date:
---

## Миналата лекция

::: nonincremental

- Научихме за NixOS, модули, overlays
- Направихме една виртуална машина, базирана на Nix конфигурация

:::

# Забелязваме нов проблем с възпроизводимостта

- Един Nix пакет зависи от `nixpkgs`, обаче никъде не дефинира точно коя версия

- Можем да правим условни изрази според версията, така че пакетът да работи на всяка версия.
  Това е трудно и скалира с времето.

- Можем да правим проверка и да хвърляме грешка.
  Но пак задължаваме потребителя ръчно да сложи коректната версия.

- Връщаме се към проблема, където различни пакети може да се нуждаят от различна версия на зависимостта (nixpkgs)
  
## flake

- Flake е атрибутно множество с:

  - `description`, текстово описание

  - `inputs`, атрибутно множество с редица входни flake-ове (тук можем да поставим nixpkgs)

  - `outputs`, функция, получаваща `inputs` и връщаща атрибутно множество с резултатните nix изрази

- За всичките входове пазим един lock файл с конкретните им версии

- Ако вход го няма, теглим го, като го има, подаваме точно тази версия на `outputs`

---

- `inputs` не е задължително поле

  ```nix
  {
      description = "Some values";
      outputs = _: {
          x = 5; y = 10;
      };
  }
  ```

# Формат на атрибути в `inputs`

- Всеки вход си има име в `inputs`

- Входовете са атрибутни множества, описващи от къде произлиза

- `fetch`-ърите директно не ни вършат работа, понеже подаваме `inputs` на `outputs`, и по време на подаване трябва да сме оценили точните стойности на `inputs`

- Използват с няколко формата, които хем автоматизират, хем опростяват

## URL

Най-простия формат:

```nix
inputs.something.url = "git+https://github.com/NixOS/patchelf";
inputs.anything.url =
    "https://github.com/NixOS/patchelf/archive/master.tar.gz";
inputs.athing.url = "github:edolstra/nix-warez";
```

## Full attribute set

По-детайлния формат.
Само `type` е универсално, останалите атрибути зависят от него.
Някои възможни типове са `git`, `tarball`, `file`, `indirect`.

```nix
{
  # Задължително
  type = "github";
  # Задължително за "github" типа
  owner = "NixOS";
  repo = "nixpkgs";
}
```

## Примери

<!-- TODO: първи без inputs, втори с input първия; с инстински input-и -->

# NixOS чрез flakes

- Можем просто да добавим `outputs` атрибут, чиято стойност е системната деривация

- По подразбиране това е под `nixosConfiguration."HOSTNAME"`

- Можем да "изкараме" самата деривация чрез `lib.nixosSystem`

## Примерен flake за система

```nix
{
  inputs.nixpkgs.url = "github:nixos/nixpkgs/nixos-24.11";
  outputs = { nixpkgs, ... }: {
    nixosConfiguration."mymach" = 
      nixpkgs.lib.nixosSystem = {
        system = "x86_64-linux";
        modules = [ ./configuration.nix ];
      };
  };
}
```

# Други употреби

- Възможността да имаш пълна възпроизводимост е много удобна

- Можем да го използваме за произволни деривации

- Ако имаш `nix` инсталиран, единственото което ти трябва е `flake`-а на деривацията и всичко останало си се оправя

- От тук се появява "новата" `nix` команда

## nix V3 командата

- Прилича на по-старите `nix-` команди, но всичко се базира върху `flake`-ове

- `nix build` вместо `nix-build`, където деривацията се взема от `outputs.package."SYSTEM"."NAME"`

- `nix develop` вместо `nix-shell`, където шел деривацията се взема от `outputs.devShells."SYSTEM"."NAME"`

- елиминираме нуждата от `nix-env`, `nix-channel`

## outputs форматът

- За да може `nix` да работи, трябва `outputs` атрибутите да са стандартизирани

  <https://wiki.nixos.org/wiki/Flakes#Output_schema>

---
title: Деривации
date:
---

## Миналата лекция

::: nonincremental

- Научихме целия Nix език
- Забавлявахме се с функционално програмиране

:::

# Функцията `derivation`

## Какво е пакет?

- Пакет е просто редица инструкции как да *компилираме* и *инсталираме* програма, заедно с нужните ѝ *зависимости*

- Ако компилираме: от къде да изтеглим сорс-кода, каква команда да пуснем за компилиране, къде да сложим резултата

- Ако взимаме готови файлове: от къде да ги вземем, какви patch-ове да пуснем, къде да сложим резултата

- Nix улеснява тези подробности като ги слага под един покрив: деривации

## Какво е деривация?

- Дефинираме пакет чрез атрибутно множество,

- което се подава на вградената `derivation` функция

- Резултатът е файл в `/nix/store`, съдържащ всички инструкции съставящи пакета.
  Този файл наричаме деривация.

## `derivation`

- Функцията е вградена (идва от `builtins`)

- В аргумента трябва да съдържа:

  - архитектура на системата
  - име на пакета
  - скрипт, който ще създаде резултатаът на пакета от нулата

  ```nix
  derivation {
      # Задължителни
      system = "x86_64-linux";
      name = "hello";
      builder = ./build-script.sh;
      # Опционално
      args = [ "a" "b" ];
      outputs = [ "lib" ];
  }
  ```

## Примери

<!-- TODO -->

## Функции над derivation

- Да правиш скрипт от дъното за всяко нещо е трудоемко

- `nixpkgs` предлага няколко удобства; функции които използват `derivation`, но преодставят `system` и `builder`

- някои от тях вече сме виждали: `runCommand`, `writeTextFile`, `writeShellApplication`, `mkShell`

- Всички те зависят от една по-основна функция: `mkDerivation`

# mkDerivation

`builder` се разграничава в няколко фази (в този ред):

0. **Unpack**: разархивиране на входните файлове
1. **Patch**: слагат се patch-ове; по-общо казано, правят се промени по изтеглените сорс-файлове
2. **Configure**: конфигурира се средата за компилиране, примерно създаване на конфигурационни файлове които ще са полезни по време на компилация
3. **Build**: пуска се нужната програма за компилиране
4. **Check**: пускат се всички тестове, с целта да се провери дали компилацията е създала коректен резултат
5. **Install**: резултатните данни се слагат във финалната им локация под `/nix/store`
6. **Fixup**: финални (nix-specific) промени, примерно премахване на дебъг данни от резултата

## Атрибути в аргументът на `mkDerivation`

- `name` за име на пакета

- `version` за версия, използваме `name-version` за да обозначим пакета в `/nix/store`, заедно с хешът разира се

- `src` за **път** в който се намира изходния архив

  - Искаме да автоматизираме изтеглянето на данни и запазването им, затова имаме fetchers

---

- Всяка фаза се определя от атрибутът `namePhase` (`name` е едно от `unpack`, `patch`, `configure`, ...)

- `preName` и `postName` съответно се изпълняват преди или след дадената фаза. Така можем конструктивно да променяме фази.

- `dontName` е булева стойност, отразяваща дали дадената фаза да се изпълни.

  - Валидно е само за фазите, които се изпълняват по подразбиране
  - За другите (`check`), имаме `doName`
- Някои фази имат свои си атрибути:
  - Patch Phase: `patches`, списък от пачове които ще се сложат върху сорса
  - Configure Phase: `configureScript`, име на конфигурационен скрипт


## Fetchers

- Функции, които по подадени аргументи изтеглят някакви файлове от интернет, слагат ги в `/nix/store` и връщат **път** към тези файлове.

  Както говорехме в лекция 02, трябва да приложим и хеш.
  Почти винаги се използва SHA256, но и други се поддържат.

- Универсалният начин да намерим хешът е да накраме Nix ни го даде.
  Подаваме му празен, той тегли данните и ни хвърля грешка, че е очаквал някакъв конкретен, който безцеремонно си копираме.

- **Важна тънкост:** хешът е с предимство, т.е. ако се промени url-ът, но не и хешът, пак ще се използват файловете от стария url.
  Хешът трябва да е празен, за да накараме Nix да преизтегли данните от новата локация.

---

### fetchurl

Изтегля ресурс от подадения URL.

```nix
pkgs.fetchurl {
    url = "https://example.com/file.txt";
    hash = "sha256-lTeyxzJNQeMdu1IVdovNMtgn77jRIhSybLdMbTkf2Ww=";
}
```

`fetchzip` е същото, обаче автоматично и разархивира изтегления файл

### fetchFromGitHub

```nix
pkgs.fetchFromGitHub {
    owner = "username";
    repo = "repository";
    rev = "v1.0";
    hash = "";
}
```

---

### fetchgit

```nix
pkgs.fetchgit {
    url = "...";
    rev = "refs/tags/v1.0.0";
    hash = "";
    # Optional
    fetchSubmodules = false;
    leaveDotGit = false;
    deepClone = false;
    sparseCheckout = [ "dir/to/include" "other/dir" ];
}
```

- Fetcher-и като fetchFromGitHub използват fetchzip ако никоя от fetchgit-специфичните опции не е избрана
- **Внимание:** .git папката не е reproducible!

# Вторите деривации с mkDerivation

<!-- TODO -->
